# CHATAI

Telegram-бот с интеграцией искусственного интеллекта (Google Gemini), предназначенный для диалогового общения, генерации ответов на вопросы пользователя, а также обработки мультимодальных запросов (текст + изображение).

**Основные возможности:**
- Общение с ИИ: бот отвечает на вопросы, поддерживает диалог, учитывает историю переписки.
- Мультимодальность: можно отправлять текст и фото, бот анализирует изображение и даёт описание или ответ.
- Поддержка длинных сообщений: реализовано автоматическое разбиение текста для обхода лимитов Telegram.
- Логирование: все ответы и ошибки сохраняются в отдельную папку для анализа.
- Гибкая архитектура: легко добавлять новые команды и интеграции с другими AI.
- Ограничение доступа: бот работает только для разрешённых пользователей (список задаётся в настройках).

**Для кого полезен:**
- Для пользователей, которым нужен интеллектуальный помощник в Telegram.
- Для разработчиков, желающих расширять функционал или интегрировать другие AI.
- Для тех, кто хочет получать описания изображений или работать с большими текстами через Telegram.

## Инструкции по chatai

### Получение ключа для API gemini
Чтобы бот начал работать нужно получить ключ для API gemini

1. Идём на `https://aistudio.google.com` и регистрируемся
2. Внизу (слева) в вертикальном меню жмём - `Get API key`
3. Копируем полученный ключ, чтобы использовать в боте.

Так же можно почитать **Краткое руководство по API Gemini** - `https://ai.google.dev/gemini-api/docs/quickstart?lang=python&hl=ru`

### Необходимый минимум для работы бота

1. Установить все зависимости, используя файл `requirements.txt`
2. Переименовать файл `.env_template` в `.env`. Заполнить переменные в файле требуемыми значениями!
3. Из-за того, что используется `dotenv`, все ключи загружаются в переменные окружения и не указываются явно в коде.

### Архитектура и ключевые компоненты
- Проект — Telegram-бот с интеграцией внешнего AI (Gemini), поддержкой длинных сообщений, историей диалога и логированием.
- Главный файл запуска: `main.py`.
- Ключевые директории:
  - `api/`: интеграция с внешним AI (`gemini.py`).
  - `config_data/`: конфигурация, параметры запуска (`config.py`).
  - `handlers/`: обработчики Telegram-команд (`handlers_custom/`, `handlers_default/`).
  - `services/`: сервисные функции для работы с текстом (`text_cleaner.py`, `text_splitter.py`, `block_splitter.py`), поддержка истории (`chat_context.py`), проверка пользователя (`user_check.py`), логирование (`logging.py`).
  - `logs/`: директория для хранения логов, создаётся автоматически.

### Критические паттерны и конвенции
- Для отправки длинных сообщений используется разбиение текста на части с лимитом ~3900 символов (см. `services/block_splitter.py`, `services/text_splitter.py`).
- Для передачи очень длинных текстов используйте отправку файла через `send_document`.
- Всегда оборачивайте вызовы Telegram API (`send_message`, `send_document`) в `try-except` для предотвращения падения бота.
- Все обработчики команд оформляйте через декоратор `@bot.message_handler` (`handlers_default/start.py`, `handlers_default/help.py`).
- Сервисные функции для работы с текстом вынесены в отдельные модули в `services/`.
- Поддержка истории диалога реализована через `chat_context.py` и переменную окружения `MAX_HISTORY_LENGTH`.
- Ограничение доступа реализовано через `user_check.py` и переменную окружения `USER_ID` (список разрешённых пользователей).
- Логирование событий и ошибок реализовано через `logging.py`, логи сохраняются в директории `logs/`.
- Конфигурация токенов и параметров — в `config_data/config.py` и `.env_template`.
- Для устойчивости реализована обработка ошибок ServiceUnavailable с повторными попытками отправки сообщений (см. `main.py`).

### Взаимодействие компонентов
- Обработчики команд используют сервисы для подготовки текста, поддержки истории, проверки пользователя и логирования, а также API-модули для обращения к внешнему AI.
- Конфигурация токенов и параметров — в `config_data/config.py` и `.env_template`.

### Запуск, тестирование и отладка
- Запуск бота: `python main.py`
- Все зависимости — в `requirements.txt`
- Для отладки используйте вывод ошибок в консоль, логирование через `logging.py` и обработку исключений

### Примеры специфических решений
- Разделение длинных сообщений по параграфам и коду для сохранения структуры (`block_splitter.py`, `text_splitter.py`).
- Задержка между отправкой частей сообщения для обхода лимитов Telegram (`time.sleep(0.5)`).
- Отправка очень длинных текстов через файл (`send_document`).
- Поддержка истории диалога для каждого пользователя (`chat_context.py`).
- Ограничение доступа по ID пользователя (`user_check.py`).
- Логирование событий и ошибок с автоматическим созданием директории (`logging.py`).
- Повторные попытки отправки сообщений при ошибках ServiceUnavailable (экспоненциальная задержка).

### Внешние зависимости
- Основная библиотека для Telegram: `pyTelegramBotAPI` (telebot)
- Для интеграции с AI используйте соответствующие API-клиенты (`google-genai`, `requests`)
- Для работы с переменными окружения: `python-dotenv`

### Рекомендации для расширения
- Новые обработчики команд размещайте в соответствующих подпапках `handlers/`
- Для работы с длинным текстом используйте сервисы из `services/`
- Для поддержки новых возможностей (например, истории, проверки пользователя, логирования, устойчивости к ошибкам) создавайте отдельные сервисные модули
- Следуйте структуре и паттернам, описанным в коде проекта
- Для новых интеграций с AI создавайте отдельные модули в `api/`

### Мультимодальные запросы (текст + фото)
В проекте реализована поддержка мультимодальных запросов через кастомный обработчик `handlers_custom/gemini_handler.py`.
Для передачи текста и изображения в Gemini API используется функция:

```python
def add_message_part(message):
    current_message_parts = []
    if len(message) == 1:
        current_message_parts.append({"text": message[0]})
    elif len(message) == 2:
        current_message_parts.append({"text": message[0]})
        current_message_parts.append({
            "inline_data": {
                "mime_type": "image/jpeg",
                "data": message[1],
            }
        })
    return current_message_parts
```
Пример использования:
```python
# Для текстового запроса:
parts = add_message_part([message.text])
# Для запроса с фото:
parts = add_message_part([caption, img_base64])
```

### Обработка ошибок и устойчивость
- Все вызовы Telegram API (`send_message`, `send_document`) и Gemini API оборачиваются в `try-except` с повторными попытками при ServiceUnavailable.
- Ошибки Markdown (400) предотвращаются через правила форматирования (см. META_PROMPT в config.py).
- Логирование ошибок и ответов ИИ ведётся в папке `logs/`.

### Расширение функционала
- Для новых команд создавайте обработчики в `handlers_custom/`.
- Для поддержки мультимодальности используйте паттерн parts (text, image).
- Для сложных сценариев диалога используйте сервисы из `services/` (история, разбиение текста, очистка).

### История диалога и контекст
- История сообщений пользователя хранится в `services/chat_context.py` (user_histories).
- Контекст для ИИ формируется как список parts, включая META_PROMPT и предыдущие сообщения.

### Пример кастомного обработчика (текст + фото)
```python
@bot.message_handler(content_types=["photo"])
def handle_photo_message(message):
    ...
    img_base64 = ... # преобразование фото
    parts = add_message_part([message.caption, img_base64])
    context = context_for_ai(message.from_user.id, parts)
    result = gemini.request_ai(message.from_user.id, context)
    send_message(message, result)
```